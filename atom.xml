<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://DennyWanye.GitHub.io</id>
    <title>DennyWanye</title>
    <updated>2022-02-17T10:42:25.231Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://DennyWanye.GitHub.io"/>
    <link rel="self" href="https://DennyWanye.GitHub.io/atom.xml"/>
    <subtitle>Keep track of interesting things</subtitle>
    <logo>https://DennyWanye.GitHub.io/images/avatar.png</logo>
    <icon>https://DennyWanye.GitHub.io/favicon.ico</icon>
    <rights>All rights reserved 2022, DennyWanye</rights>
    <entry>
        <title type="html"><![CDATA[ReactDnd插件使用]]></title>
        <id>https://DennyWanye.GitHub.io/post/reactdnd-cha-jian-shi-yong/</id>
        <link href="https://DennyWanye.GitHub.io/post/reactdnd-cha-jian-shi-yong/">
        </link>
        <updated>2022-02-16T07:29:53.000Z</updated>
        <content type="html"><![CDATA[<p>### <strong>一个用ReactDnd库做的一个Demo</strong></p>
<p>主要用到的两个方法：<code>DropTarget</code> <code>DragSource</code></p>
<p>Example.js:</p>
<pre><code class="language-jsx">import Container from './Container';
import { DndProvider } from &quot;react-dnd&quot;;
import { HTML5Backend } from &quot;react-dnd-html5-backend&quot;;

export const Example = () =&gt; {
    return (&lt;DndProvider backend={ HTML5Backend }&gt;
        &lt;Container /&gt;
    &lt;/DndProvider&gt;);
};

</code></pre>
<p>Container.js:</p>
<pre><code class="language-jsx">import React, { PureComponent } from 'react'
import TabItem from &quot;./TabItem&quot;;

export default class Container extends PureComponent{

    constructor(props) {
        super(props)
        this.state = {
            tabs: [1,2,3,4,5,6,7,8,9,10],
        }
    }

    changeTabLocation = (index, targetIndex) =&gt; {
        if(this.state.tabs) {
            const tabs = this.state.tabs
            let temp = tabs[index]
            tabs[index] = tabs[targetIndex]
            tabs[targetIndex] = temp
            this.setState(tabs)
        }
    }

    renderTabs() {
        return &lt;TabItem tabs={this.state.tabs} changeTabLocation={this.changeTabLocation.bind(this)} /&gt;
    }

    render() {
        return (&lt;div className=&quot;container&quot;&gt;
            {this.renderTabs()}
        &lt;/div&gt;)
    }
}

</code></pre>
<p>TabItem.js:</p>
<pre><code class="language-jsx">import React, { PureComponent } from 'react'
import { DragSource, DropTarget } from 'react-dnd'
import { ItemTypes } from './ItemTypes.js'



class ItemCom extends PureComponent {
    constructor(props) {
        super(props);
    }

    render(){
        const { content, connectDropTarget, connectDragSource, isDragging } = this.props
        const opacity = isDragging ? 0 : 1
        return connectDropTarget(connectDragSource(&lt;div style={{ opacity }} className=&quot;tab-item&quot;&gt;{content}&lt;/div&gt;))
    }
}

const dropTarget = DropTarget(ItemTypes.TAB, {
    drop(props, monitor, component) {
        if(props.index != monitor.getItem().index) {
            props.changeTabLocation(props.index, monitor.getItem().index)
        }
        console.log(props)
        console.log(monitor.getItem())
    },
},(connect)=&gt; ({
    connectDropTarget: connect.dropTarget(),
}))(ItemCom)

const DargSourceDom = DragSource( ItemTypes.TAB, {
        beginDrag(props) {
            const { content, index } = props;
            return { content, index };
        },
    }, (connect, monitor) =&gt; ({
        connectDragSource: connect.dragSource(),
        isDragging: monitor.isDragging(),
    })
)(dropTarget)


const TabItem = ({ tabs, changeTabLocation}) =&gt; {
    return &lt;div&gt;
        {
            tabs.map((item,index)=&gt; {
                return &lt;DargSourceDom index={index} changeTabLocation={changeTabLocation}  content={item}/&gt;
            })
        }
    &lt;/div&gt;
}

export default TabItem

</code></pre>
<ol>
<li>
<p>在 <code>DropTarget</code> 中对于 <code>drop</code> 的处理</p>
</li>
<li>
<p>对于 <code>DropTarget</code> <code>DragSource</code> 所做的包裹处理。</p>
<p>这两个方法第三个参数都是传到 <code>ItemCom</code> 中的  <code>props</code> 中。</p>
<p>​	关于 <code>monitor</code> 中可以监听到的状态 这里有详细的介绍 <a href="https://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor">DragSourceMonitor</a> <a href="https://react-dnd.github.io/react-dnd/docs/api/drop-target-monitor">DropTargetMonitor</a> 。</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React.memo()]]></title>
        <id>https://DennyWanye.GitHub.io/post/reactmemo/</id>
        <link href="https://DennyWanye.GitHub.io/post/reactmemo/">
        </link>
        <updated>2022-02-15T04:00:04.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1怎么使用">1.怎么使用</h3>
<p>React.memo 是用来决定在何种条件改变下，组件重新渲染。可以减少一次渲染中组件渲染的数量，从而提升用户体验。</p>
<pre><code class="language-javascript">React.memo(MyComponent, areEqual)

function areEqual () {
    /*
  return true if passing nextProps to render would return
  the same result as passing prevProps to render,
  otherwise return false
  */
}
</code></pre>
<p>MyComponent: 代表的是你需要包裹的组件。</p>
<p>areEqual： 是可选项，判断是否进行渲染的函数，返回值为布尔值。</p>
<h3 id="2注意项">2.注意项</h3>
<p>2.1 当areEqual没有传入的时候，其是比较组件的 props ，来判断组件是否变更，如果变更就进行重新渲染，如果没有就不对该组件进行渲染。</p>
<p>2.2 React.memo的作用原理是判断props是否发生改变（或者是传入的areEqual函数返回的布尔值），如果是true，就重新渲染组件，反之不做其他操作。如果你的组件中有用到 <a href="https://reactjs.org/docs/hooks-state.html"><code>useState</code></a>, <a href="https://reactjs.org/docs/hooks-reference.html#usereducer"><code>useReducer</code></a> 或者 <a href="https://reactjs.org/docs/hooks-reference.html#usecontext"><code>useContext</code></a> Hook的话，当state或者context改变的时候，该组件还是会更新。</p>
<p>2.3 当你向被memo包裹的组件传入回调函数的时候，在每一次渲染时，父组件都会提供一个不同的函数实例，这也就导致此时即使你的其他props数据都相同，但是因为传入的回调函数实例不同，导致每次渲染都会刷新该组件。</p>
<p>原因：</p>
<pre><code class="language-javascript">function sumNumber() {
    return (a, b) =&gt; a + b
}

const sum1 = sumNumber()
const sum2 = sumNumber()

console.log(sum1 === sum1)  //=&gt; true
console.log(sum2 === sum2)  //=&gt; true
console.log(sum1 === sum2)  //=&gt; false
</code></pre>
<p>此时我们可以用 <a href="https://reactjs.org/docs/hooks-reference.html#usecallback"><code>useCallback</code></a>来解决</p>
<pre><code class="language-javascript">const MemoizedLogout = React.memo(Logout);
function MyApp({ store, cookies }) {
  const onLogout = useCallback(
    () =&gt; cookies.clear('session'), 
    [cookies]
  );
  return (
    &lt;div className=&quot;main&quot;&gt;
      &lt;header&gt;
        &lt;MemoizedLogout
          username={store.username}
          onLogout={onLogout}
        /&gt;
      &lt;/header&gt;
      {store.content}
    &lt;/div&gt;
  );
}
</code></pre>
<p>###3.何时使用React.memo</p>
<p>3.1 &quot;Performance-related changes applied incorrectly can even harm performance. Use React.memo() wisely.&quot;</p>
<p>可使用规则： 如果你不能确认性能提升的多少，就不要使用React.memo</p>
<p>3.2 &quot;Performance-related changes applied incorrectly can even harm performance. Use React.memo() wisely.&quot;</p>
<p>一般来说，对于类组件，不建议使用React.memo()。类组件可以使用<code>shouldComponentUpdate()</code>方法，或者对 <code>PureComponent</code> 类组件进行扩展。</p>
<p>3.3 小心无用的比较</p>
<p><code>React.memo</code> 总是执行两件事：</p>
<ol>
<li>调用比较函数，来确认props是否发生改变</li>
<li>如果发生了改变就渲染更新该组件，没有就不做渲染<br>
所以当你在错误的地方调用了 <code>React.memo</code> 的时候，也就会错误的调用比较函数，造成性能的浪费。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[费曼学习法]]></title>
        <id>https://DennyWanye.GitHub.io/post/fei-man-xue-xi-fa/</id>
        <link href="https://DennyWanye.GitHub.io/post/fei-man-xue-xi-fa/">
        </link>
        <updated>2022-02-15T03:01:41.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://images.pexels.com/photos/3772712/pexels-photo-3772712.jpeg?auto=compress&amp;cs=tinysrgb&amp;dpr=2&amp;w=1920" alt="" loading="lazy"></figure>
<h3 id="1确定目标">1.确定目标</h3>
<p>确认自己对这个目标是否有强烈的动机</p>
<h3 id="2模拟教学">2.模拟教学</h3>
<p><strong>通过教授他人，教授者对于知识的吸收率达到了90%。</strong></p>
<p>我们可以在博客中写文章，模拟自己教授他人的情况，来近似达到这一目的（存疑？）</p>
<figure data-type="image" tabindex="2"><img src="https://DennyWanye.GitHub.io/post-images/1644895331651.png" alt="" loading="lazy"></figure>
<p>注意：学习金字塔不一定是科学的，现在它的出处也无从考究，但它的理念很有启发性。</p>
<h3 id="3重复回顾">3.重复回顾</h3>
<p>在上述的两个过程中，会产生新的目标（也就是新的问题、发现新的知识盲区等等），此时我们就需要重复上述的步骤，来解决新的目标——通过查找各种资料，将新的目标解决，然后将解决的过程记录并背下来，讲给想象中的小白听，在博客上就是将解决目标的过程梳理成教程记录下来。</p>
<p><strong>注意：重点是需要用自己思考之后的语言表达出来。</strong></p>
<h3 id="4概念简化">4.概念简化</h3>
<p>费曼老爷子有一句很经典的话「If I couldn’t reduce it to the freshman level. That means we really don’t understand it.」</p>
<p>将知晓的概念简化，</p>
<p><strong>是用更简单的概念来表达，而不是用更少的语言来表达</strong>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Rule for coding]]></title>
        <id>https://DennyWanye.GitHub.io/post/rule-for-coding/</id>
        <link href="https://DennyWanye.GitHub.io/post/rule-for-coding/">
        </link>
        <updated>2022-02-14T10:17:46.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://images.pexels.com/photos/7092371/pexels-photo-7092371.jpeg?auto=compress&amp;cs=tinysrgb&amp;dpr=1&amp;w=1920" alt="" loading="lazy"></figure>
<p><strong>If a component doesn't need some data for rendering, it doesn't need that data at all.</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[舒适区]]></title>
        <id>https://DennyWanye.GitHub.io/post/comfort-zone/</id>
        <link href="https://DennyWanye.GitHub.io/post/comfort-zone/">
        </link>
        <updated>2022-02-14T05:08:04.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://images.pexels.com/photos/5255255/pexels-photo-5255255.jpeg?auto=compress&amp;cs=tinysrgb&amp;dpr=1&amp;w=1920" alt="" loading="lazy"><br>
每个人都是趋向于舒适区，而且舒适区的范围也会随着主体的适应范围而变。</p>
<ul>
<li>如果本体一下子步入到舒适区之外太远，本体则会感到极端的不适应、对于本体的成长会非常不利。</li>
<li>如果本体一直在不断的步入舒适区之外，本体也会感到疲倦、难受。</li>
<li>如果本体一直呆在舒适区的范围中，本体会感到无趣乃至生活如一潭死水。</li>
</ul>
<p>也就意味着：</p>
<ul>
<li>不应该离开自己的舒适区太远</li>
<li>舒适区对于<strong>生活中的困难</strong>来说是一个相对性概念。因为本体变强，所以以前觉得困难的事情，现在觉得简单。</li>
<li>一直呆在舒适区中，会变得失去斗志，会变成中年胖大叔。</li>
</ul>
<p>所以，不要自己变成中年胖大叔，不要自己变成一潭死水，应该：</p>
<ul>
<li>一点点的探索本体舒适区的极限，当然是在适合自己的感兴趣的方向。</li>
<li>小心<strong>温水煮青蛙</strong></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[第一次使用Blog]]></title>
        <id>https://DennyWanye.GitHub.io/post/first_blog/</id>
        <link href="https://DennyWanye.GitHub.io/post/first_blog/">
        </link>
        <updated>2021-12-11T11:03:00.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://images.pexels.com/photos/629162/pexels-photo-629162.jpeg?cs=srgb&amp;dl=pexels-eberhard-grossgasteiger-629162.jpg&amp;fm=jpg&amp;h=400" alt="" loading="lazy"></figure>
<p>于2022/2/11第一次使用Gridea做了这个blog（在同事的建议下）。最开始的原因是记录开发中遇见的问题，方便后续的查阅。但现在想一想觉得，也可以记录下来一些自己的所思所想。因为博客的意义是<strong>记录</strong></p>
]]></content>
    </entry>
</feed>