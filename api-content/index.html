{"posts":[{"title":"flex布局的flex-grow、flex-shrink、flex-basis","content":"flex-basis： 用于设置子元素占用的空间。 如果设置为 flex-basis: auto;，子项的宽度由其 width数值决定，如果宽度为 auto，则由其内容撑起的宽度决定。 如果设置为 flex-basis: 700px;，则子项的宽度会被覆盖为700px。 flex-grow：用来“瓜分”父项的“剩余空间”。 根据每个子项flex-grow 的值，来“瓜分”父项的剩余空间。 例子： .father{ width: 500px; height: 30px; display: flex; background-color: #eee; } .children-1 { width: 100px; background-color: pink; } .children-2 { width: 100px; flex-grow: 1; background-color: blue; } .children-3 { width: 100px; flex-grow: 3; background-color: red; } &lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;children-1&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;children-2&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;children-3&quot;&gt;3&lt;/div&gt; &lt;/div&gt; 默认为0，即不参与瓜分 瓜分的份数 = 每个子项flex-grow的数量之和 瓜分的宽度 = 父项未分配出去的宽度，此时为 500 - 300 = 200px 每个子项瓜分到的宽度 = 瓜分的宽度 / 瓜分的份数 * 子项 flex-grow的数量 flex-shrink用来“吸收”超出的空间 .father{ width: 500px; height: 30px; display: flex; background-color: #eee; } .children-1 { width: 300px; flex-basis: 400px; background-color: pink; } .children-2 { width: 100px; flex-basis: 200px; background-color: blue; flex-shrink: 1; } .children-3 { width: 100px; flex-basis: auto; background-color: red; flex-shrink: 2; } 因为flex-basis: 400px覆盖了原本设置的宽度，所以children-1的宽度为 400px。 同理children-2的宽度为200px。 因为flex-basis: auto，所以children-3的宽度为width的宽度，即是100px。 超出的宽度为200px 因为flex-shrink默认值为1，所以子项的flex-shrink值总和为 4。 每个子项所减少的宽度 = 200px / 4 * 每个子项的flex-shrink的值。 [原教程链接](flex-basis： 用于设置子元素占用的空间。 如果设置为 flex-basis: auto;，子项的宽度由其 width数值决定，如果宽度为 auto，则由其内容撑起的宽度决定。 如果设置为 flex-basis: 700px;，则子项的宽度会被覆盖为700px。 flex-grow：用来“瓜分”父项的“剩余空间”。 根据每个子项flex-grow 的值，来“瓜分”父项的剩余空间。 例子： .father{ width: 500px; height: 30px; display: flex; background-color: #eee; } .children-1 { width: 100px; background-color: pink; } .children-2 { width: 100px; flex-grow: 1; background-color: blue; } .children-3 { width: 100px; flex-grow: 3; background-color: red; } &lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;children-1&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;children-2&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;children-3&quot;&gt;3&lt;/div&gt; &lt;/div&gt; 默认为0，即不参与瓜分 瓜分的份数 = 每个子项flex-grow的数量之和 瓜分的宽度 = 父项未分配出去的宽度，此时为 500 - 300 = 200px 每个子项瓜分到的宽度 = 瓜分的宽度 / 瓜分的份数 * 子项 flex-grow的数量 flex-shrink用来“吸收”超出的空间 .father{ width: 500px; height: 30px; display: flex; background-color: #eee; } .children-1 { width: 300px; flex-basis: 400px; background-color: pink; } .children-2 { width: 100px; flex-basis: 200px; background-color: blue; flex-shrink: 1; } .children-3 { width: 100px; flex-basis: auto; background-color: red; flex-shrink: 2; } 因为flex-basis: 400px覆盖了原本设置的宽度，所以children-1的宽度为 400px。 同理children-2的宽度为200px。 因为flex-basis: auto，所以children-3的宽度为width的宽度，即是100px。 超出的宽度为200px 因为flex-shrink默认值为1，所以子项的flex-shrink值总和为 4。 每个子项所减少的宽度 = 200px / 4 * 每个子项的flex-shrink的值 原教程链接 ","link":"https://DennyWanye.GitHub.io/post/flex-bu-ju-de-flex-growflex-shrinkflex-basis/"},{"title":"体内平衡机制","content":" 1. 原理： 我们大脑产生快感和痛感的区域是重叠的，每一次因为多巴胺产生的快感，身体会用自动用一定的痛感来平衡它。在生理学叫做体内平衡。 也就是当你通过行动A产生快感后，体内平衡机制会让你产生以下情况，也即是痛感： 渴望更多 负面的情绪 降低行动A产生的快感强度 如果我们什么都不做，体内平衡会恢复到某种平衡状态。 例子：吸毒，当你吸毒后，会产生巨大的快感。之后会让你想要更多，以及当长时间不吸毒后的戒断反应。戒断反应就是平衡机制产生的痛感（焦虑、烦躁的情绪等）。无限循环之后，产生的痛感就会长时间存在，而吸毒（同样数量和品质的）产生的快感会降低。所以个体就会追求更加刺激的毒品。而当该个体想要戒毒的时候，产生的戒断反应就是痛感的极端表达。 人体内部存在一种平衡，这种平衡起到调节生物体快感和痛感的作用。具体的机制就是：当你做一件事情感觉到快感的之后，体内平衡机制就会产生相应比例（比例是多少呢？）的痛感。反之，当你做一件事情感受到痛感的之后，体内平衡机制就会产生相应比例的快感。 2.这是一种人体的机制（生物体的机制？） 2.1 机制的边界情况 2.1.1多巴胺枯竭 如果不断的追求快感，就会进入一种多巴胺枯竭的状态。从而很难去做一件困难的事情。 例如：如果你早上醒了一直刷抖音，就会很难起床。 2.1.2 体内平衡的机制被打破 就像刚刚说的吸毒，当体内平衡机制被打破时，新的平衡会建立。个体感受到快感的阙值会上升。感受到痛感的阙值会下降。反之如果你一直追求痛感（假设），新的机制平衡建立后，痛感的阙值会上升，快感的阙值会下降。 阙值被打破的条件：（主动或者被动）一直感受到超出体内平衡机制平衡点的快感或痛感，当个体习惯（笼统的说法）了之后，新的平衡被建立。 3.如何利用机制 3.1 追求痛苦 要点：主动做一些会产生痛感的事情，之后根据机制，身体会产生快感。此时，产生的痛感不仅不会产生焦虑，还会缓解焦虑。会产生多巴胺和内啡肽（止痛）产生快感。 3.2 控制快感和痛感的获取 上面一张图为做事情产生的多巴胺数量，喝一杯咖啡为130，最后一项吸食冰毒为1300。红线以下为会破坏机制平衡的。 管理好每天做高快感事情的时间。上图中红线以上的就是正常生活中高多巴胺的行为。如果个体在一天中先做高多巴胺的行为，该个体在之后的一段时间内，就会面临痛感的负面状态（焦虑，烦躁等甚至是多巴胺枯竭），导致很难甚至没有办法完成一些需要去处理且有痛感的事情。 所以，可以先做需要处理且有痛感的事情，之后的时间内因为我们先做了有痛感的事情，我们会得到机制反馈的且能缓解焦虑的快感。 3.3 降低快感的预期 例子：还记得条件反射的实验吗？就是摇铃铛，就给狗子食物吃。实验者最后只是摇铃铛狗都会流出口水。 这就是预期带来的快感，这种快感是没有实际利益的。狗子并没有得到食物，只是听到了铃铛的声音。 所以可以通过降低快感的预期，也即是降低预期带来的快感，从而降低快感的获取。 奖励预判误差 做可以获得快感的行为A，仅仅只是将成功的概率调整到50%，多巴胺即会在行动过程中上升到一个很大的水平，也是赌博之所以吸引力的原因。 所以尽量不要去碰这种涉及到奖励预判误差。 3.4延迟消费多巴胺 当个体被身体驱动去做一些高快感的事情A时，可以通过正念冥想（方法的一种）来暂时放置去做事情A的冲动。 例子：当你在减肥时，睡觉前饿的受不了，非常想要吃东西。可以进行正念冥想，来暂时放置这种想要吃东西的冲动。等待这种冲动慢慢消失。 多巴胺是我们人类寻找未来资源的货币，我们只有认识并管理它，才不会过度消费这个货币。 ————Andrew Huberman 原视频地址 ","link":"https://DennyWanye.GitHub.io/post/ti-nei-ping-heng-ji-zhi/"},{"title":"ReactDnd插件使用","content":"### 一个用ReactDnd库做的一个Demo 主要用到的两个方法：DropTarget DragSource Example.js: import Container from './Container'; import { DndProvider } from &quot;react-dnd&quot;; import { HTML5Backend } from &quot;react-dnd-html5-backend&quot;; export const Example = () =&gt; { return (&lt;DndProvider backend={ HTML5Backend }&gt; &lt;Container /&gt; &lt;/DndProvider&gt;); }; Container.js: import React, { PureComponent } from 'react' import TabItem from &quot;./TabItem&quot;; export default class Container extends PureComponent{ constructor(props) { super(props) this.state = { tabs: [1,2,3,4,5,6,7,8,9,10], } } changeTabLocation = (index, targetIndex) =&gt; { if(this.state.tabs) { const tabs = this.state.tabs let temp = tabs[index] tabs[index] = tabs[targetIndex] tabs[targetIndex] = temp this.setState(tabs) } } renderTabs() { return &lt;TabItem tabs={this.state.tabs} changeTabLocation={this.changeTabLocation.bind(this)} /&gt; } render() { return (&lt;div className=&quot;container&quot;&gt; {this.renderTabs()} &lt;/div&gt;) } } TabItem.js: import React, { PureComponent } from 'react' import { DragSource, DropTarget } from 'react-dnd' import { ItemTypes } from './ItemTypes.js' class ItemCom extends PureComponent { constructor(props) { super(props); } render(){ const { content, connectDropTarget, connectDragSource, isDragging } = this.props const opacity = isDragging ? 0 : 1 return connectDropTarget(connectDragSource(&lt;div style={{ opacity }} className=&quot;tab-item&quot;&gt;{content}&lt;/div&gt;)) } } const dropTarget = DropTarget(ItemTypes.TAB, { drop(props, monitor, component) { if(props.index != monitor.getItem().index) { props.changeTabLocation(props.index, monitor.getItem().index) } console.log(props) console.log(monitor.getItem()) }, },(connect)=&gt; ({ connectDropTarget: connect.dropTarget(), }))(ItemCom) const DargSourceDom = DragSource( ItemTypes.TAB, { beginDrag(props) { const { content, index } = props; return { content, index }; }, }, (connect, monitor) =&gt; ({ connectDragSource: connect.dragSource(), isDragging: monitor.isDragging(), }) )(dropTarget) const TabItem = ({ tabs, changeTabLocation}) =&gt; { return &lt;div&gt; { tabs.map((item,index)=&gt; { return &lt;DargSourceDom index={index} changeTabLocation={changeTabLocation} content={item}/&gt; }) } &lt;/div&gt; } export default TabItem 在 DropTarget 中对于 drop 的处理 对于 DropTarget DragSource 所做的包裹处理。 这两个方法第三个参数都是传到 ItemCom 中的 props 中。 ​ 关于 monitor 中可以监听到的状态 这里有详细的介绍 DragSourceMonitor DropTargetMonitor 。 添加 CustomDragLayer 3.1 添加 CunstomDragLayer import Container from './Container'; import CustomDragLayer from './CustomDragLayer'; import { DndProvider } from &quot;react-dnd&quot;; import {HTML5Backend} from &quot;react-dnd-html5-backend&quot;; export const Example = () =&gt; { return (&lt;DndProvider backend={ HTML5Backend }&gt; &lt;Container /&gt; &lt;CustomDragLayer /&gt; &lt;/DndProvider&gt;); }; CustomDragLayer.js import { DragLayer } from 'react-dnd'; import { ItemTypes } from './ItemTypes'; import { BoxDragPreview } from './BoxDragPreview'; const layerStyles = { position: 'fixed', pointerEvents: 'none', zIndex: 100, left: 0, top: 0, width: '100%', height: '100%', }; function getItemStyles (props) { const { initialOffset, currentOffset } = props if (!initialOffset || !currentOffset) { return { display: 'none' } } let { x, y } = currentOffset y = initialOffset.y const transform = `translate(${x}px, ${y}px)` return { transform: transform, WebkitTransform: transform } } const CustomDragLayer = (props) =&gt; { const { item, itemType, isDragging } = props; function renderItem() { switch (itemType) { case ItemTypes.BOX: return &lt;BoxDragPreview title={item.title}/&gt;; default: return null; } } if (!isDragging) { return null; } return (&lt;div style={layerStyles}&gt; &lt;div style={getItemStyles(props)}&gt;{renderItem()}&lt;/div&gt; &lt;/div&gt;); }; export default DragLayer((monitor,props) =&gt; { return ({ item: monitor.getItem(), itemType: monitor.getItemType(), initialOffset: monitor.getInitialSourceClientOffset(), currentOffset: monitor.getSourceClientOffset(), isDragging: monitor.isDragging(), }) })(CustomDragLayer); 3.2 隐藏原生的拖动动画 import { PureComponent } from 'react'; import { DragSource } from 'react-dnd'; import { getEmptyImage } from 'react-dnd-html5-backend'; import { ItemTypes } from './ItemTypes'; import { Box } from './Box'; function getStyles(props) { const { left, top, isDragging } = props; const transform = `translate3d(${left}px, ${top}px, 0)`; return { position: 'absolute', transform, WebkitTransform: transform, // IE fallback: hide the real node using CSS when dragging // because IE will ignore our custom &quot;empty image&quot; drag preview. opacity: isDragging ? 0 : 1, height: isDragging ? 0 : '', }; } class DraggableBox extends PureComponent { componentDidMount() { const { connectDragPreview } = this.props; if (connectDragPreview) { // Use empty image as a drag preview so browsers don't draw it // and we can draw whatever we want on the custom drag layer instead. connectDragPreview(getEmptyImage(), { // IE fallback: specify that we'd rather screenshot the node // when it already knows it's being dragged so we can hide it with CSS. captureDraggingState: true, }); } } render() { const { title, connectDragSource } = this.props; return connectDragSource(&lt;div style={getStyles(this.props)} role=&quot;DraggableBox&quot;&gt; &lt;Box title={title}/&gt; &lt;/div&gt;); } } export default DragSource(ItemTypes.BOX, { beginDrag(props) { const { id, title, left, top } = props; return { id, title, left, top }; }, }, (connect, monitor) =&gt; ({ connectDragSource: connect.dragSource(), connectDragPreview: connect.dragPreview(), isDragging: monitor.isDragging(), }))(DraggableBox); 3.3 这种CustomDragLayer的核心方法就是 CustomDragLayer.js中的 getItemStyles: function getItemStyles (props) { const { initialOffset, currentOffset } = props if (!initialOffset || !currentOffset) { return { display: 'none' } } let { x, y } = currentOffset y = initialOffset.y //这里的 x y 坐标就是计算出来的 定制化拖动对象坐标 const transform = `translate(${x}px, ${y}px)` return { transform: transform, WebkitTransform: transform } } ","link":"https://DennyWanye.GitHub.io/post/reactdnd-cha-jian-shi-yong/"},{"title":"React.memo()","content":"1.怎么使用 React.memo 是用来决定在何种条件改变下，组件重新渲染。可以减少一次渲染中组件渲染的数量，从而提升用户体验。 React.memo(MyComponent, areEqual) function areEqual () { /* return true if passing nextProps to render would return the same result as passing prevProps to render, otherwise return false */ } MyComponent: 代表的是你需要包裹的组件。 areEqual： 是可选项，判断是否进行渲染的函数，返回值为布尔值。 2.注意项 2.1 当areEqual没有传入的时候，其是比较组件的 props ，来判断组件是否变更，如果变更就进行重新渲染，如果没有就不对该组件进行渲染。 2.2 React.memo的作用原理是判断props是否发生改变（或者是传入的areEqual函数返回的布尔值），如果是true，就重新渲染组件，反之不做其他操作。如果你的组件中有用到 useState, useReducer 或者 useContext Hook的话，当state或者context改变的时候，该组件还是会更新。 2.3 当你向被memo包裹的组件传入回调函数的时候，在每一次渲染时，父组件都会提供一个不同的函数实例，这也就导致此时即使你的其他props数据都相同，但是因为传入的回调函数实例不同，导致每次渲染都会刷新该组件。 原因： function sumNumber() { return (a, b) =&gt; a + b } const sum1 = sumNumber() const sum2 = sumNumber() console.log(sum1 === sum1) //=&gt; true console.log(sum2 === sum2) //=&gt; true console.log(sum1 === sum2) //=&gt; false 此时我们可以用 useCallback来解决 const MemoizedLogout = React.memo(Logout); function MyApp({ store, cookies }) { const onLogout = useCallback( () =&gt; cookies.clear('session'), [cookies] ); return ( &lt;div className=&quot;main&quot;&gt; &lt;header&gt; &lt;MemoizedLogout username={store.username} onLogout={onLogout} /&gt; &lt;/header&gt; {store.content} &lt;/div&gt; ); } ###3.何时使用React.memo 3.1 &quot;Performance-related changes applied incorrectly can even harm performance. Use React.memo() wisely.&quot; 可使用规则： 如果你不能确认性能提升的多少，就不要使用React.memo 3.2 &quot;Performance-related changes applied incorrectly can even harm performance. Use React.memo() wisely.&quot; 一般来说，对于类组件，不建议使用React.memo()。类组件可以使用shouldComponentUpdate()方法，或者对 PureComponent 类组件进行扩展。 3.3 小心无用的比较 React.memo 总是执行两件事： 调用比较函数，来确认props是否发生改变 如果发生了改变就渲染更新该组件，没有就不做渲染 所以当你在错误的地方调用了 React.memo 的时候，也就会错误的调用比较函数，造成性能的浪费。 ","link":"https://DennyWanye.GitHub.io/post/reactmemo/"},{"title":"费曼学习法","content":" 1.确定目标 确认自己对这个目标是否有强烈的动机 2.模拟教学 通过教授他人，教授者对于知识的吸收率达到了90%。 我们可以在博客中写文章，模拟自己教授他人的情况，来近似达到这一目的（存疑？） 注意：学习金字塔不一定是科学的，现在它的出处也无从考究，但它的理念很有启发性。 3.重复回顾 在上述的两个过程中，会产生新的目标（也就是新的问题、发现新的知识盲区等等），此时我们就需要重复上述的步骤，来解决新的目标——通过查找各种资料，将新的目标解决，然后将解决的过程记录并背下来，讲给想象中的小白听，在博客上就是将解决目标的过程梳理成教程记录下来。 注意：重点是需要用自己思考之后的语言表达出来。 4.概念简化 费曼老爷子有一句很经典的话「If I couldn’t reduce it to the freshman level. That means we really don’t understand it.」 将知晓的概念简化， 是用更简单的概念来表达，而不是用更少的语言来表达。 ","link":"https://DennyWanye.GitHub.io/post/fei-man-xue-xi-fa/"},{"title":"Rule for coding","content":" If a component doesn't need some data for rendering, it doesn't need that data at all. think more, and do less. Use reverse thinking. ","link":"https://DennyWanye.GitHub.io/post/rule-for-coding/"},{"title":"舒适区","content":" 每个人都是趋向于舒适区，而且舒适区的范围也会随着主体的适应范围而变。 如果本体一下子步入到舒适区之外太远，本体则会感到极端的不适应、对于本体的成长会非常不利。 如果本体一直在不断的步入舒适区之外，本体也会感到疲倦、难受。 如果本体一直呆在舒适区的范围中，本体会感到无趣乃至生活如一潭死水。 也就意味着： 不应该离开自己的舒适区太远 舒适区对于生活中的困难来说是一个相对性概念。因为本体变强，所以以前觉得困难的事情，现在觉得简单。 一直呆在舒适区中，会变得失去斗志，会变成中年胖大叔。 所以，不要自己变成中年胖大叔，不要自己变成一潭死水，应该： 一点点的探索本体舒适区的极限，当然是在适合自己的感兴趣的方向。 小心温水煮青蛙 ","link":"https://DennyWanye.GitHub.io/post/comfort-zone/"},{"title":"第一次使用Blog","content":" 于2022/2/11第一次使用Gridea做了这个blog（在同事的建议下）。最开始的原因是记录开发中遇见的问题，方便后续的查阅。但现在想一想觉得，也可以记录下来一些自己的所思所想。因为博客的意义是记录 ","link":"https://DennyWanye.GitHub.io/post/first_blog/"}]}